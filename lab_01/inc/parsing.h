/**
*   \file parsing.c 
*   \brief Парсинг
*   \author Ивахненко Дмитрий
*   \date 21.09.2020
*
*   Данный файл содержит реализацию парсинга введенных чисел
*/

#ifndef PARSING_H
#define PARSING_H

#include "data_structures.h"

/**
    \brief функция для опеределения знака числа
    \param[in] e_num строка, содержащая число, знак которого необходимо определить (entered_num)
    \param[out] p_num число, которое парсим.
    \return OK - если знак числа явно указан. NOSIGN - если знак числа не указан явно.
*/
int parse_sign(const lrstr_t e_num, mant_t *p_num);


/**
    \brief функция для определения позиции точки в числе
    \param[in] e_num строка, содержащая число, в котором нужно определить точку (entered_num)
    \param[out] pos позиция искомой точки
    \return OK - если удалось определить позицию точки. ERR_DOR_PARSE - если было найдено более одной точки

    Примечание: если точка в числе явно не указана, считается, что она стоит после последней цифры в мантиссе
*/
int parse_dot(const lrstr_t e_num, uint8_t *pos);
 /*  
        В случае, если не было найдено ни одной значащей цифры в мантиссе, то 
        возвращается NO_SIGNIFICANT_DIGIT и в pos присваивается индекс первого 
        элемента после мантиссы
    */

/**
    \brief функция для определения позиции первой значащей цифры в мантиссе
    \param[in] e_num строка, содержащая число, в котором нужно найти значащую цифру (entered_num)
    \param[out] pos позиция искомой цифры
    \return OK - если удалось найти значащую цифру в мантиссе. ERR_S_DIGIT_PARSE - если не было найдено значащей цифры.

    Примечание: если значащей цифры найдено не было, pos присваивается индекс позиции первого символа после мантиссы
*/
int parse_significant_digit(const lrstr_t e_num, uint8_t *pos);

/**
    \brief функция для парсинга длинного целого числа из строки
    \param[in] e_num строка, содержащая число, которое нужно распарсить (entered_num)
    \param[out] p_num длинное целое число - результат парсинга
    \return OK - в случае успешного парсинга. NUMBER_IS_ZERO - в случае, если число является нулем. 
    ERR_INTEGER_PARSE - если не удалось распарсиить число ввиду его некорректности
*/
int parse_integer(const lstr_t e_num, lreal_t *p_num);

/**
    \brief функция для парсинга экспоненты вещественного числа
    \param[in] exp указатель на первый символ после символа экспоненты (e/E)
    \param[out] p_num длинное вещественное - результат парсинга
    \return OK - в случае успешного парсинга. 
    ERR_EXP_OVERFLOW - если обнаружено переполнение экспоненты 
    ERR_EXP_PARSE - если произошла ошибка при парсинге экспоненты
*/
int parse_exp(const char *exp, lreal_t *p_num);

/**
    \brief функция для парсинга длинного вещественного числа из строки
    \param[in] e_num строка, содержащая число, которое нужно распарсить (entered_num)
    \param[out] p_num длинное вещественное - результат парсинга
    \return OK - в случае успешного парсинга. NUMBER_IS_ZERO - в случае, если число является нулем. 
    ERR_MANTISSA_OVERFLOW - если при обнаружено переполнение мантиссы. 
    ERR_EXP_OVERFLOW - если обнаружено переполнение экспоненты 
    ERR_EXP_PARSE - если произошла ошибка при парсинге экспоненты
    ERR_REAL_PARSE - если произошла ошибка при парсинге
*/
int parse_real(const lrstr_t e_num, lreal_t *p_num);


  /*
        Проверяет, что строка str_str состоит только из цифр или точек. (Не включая end_pos)
        В случае успеха, возвращает TRUE, иначе - FALSE.
    */
/**
    \brief проверка корректности мантиссы
    \param[in] str_start указатель на первый символ мантиссы
    \param[in] str_end указатель на первый символ после мантиссы
    \return TRUE/FALSE
*/
bool_t is_correct_mantissa(const char * const str_start, const char * const str_end);


#endif // PARSING_H